# Array

## ## APS(Algorithm Problem Solving) : 목표 중 하나는 보다 좋은 알고리즘을 이해하고 활용

## 무엇이 좋은 알고리즘인가?

### 정확성

### 작업량

### 메모리 사용량

### 단순성

### 최적성

시험 입장에서는 정확성, 작업량(시간 ad~pro)

시간이 얼마나 걸리는지는 명령어의 개수로 표현하기도 하는데, 이를 **시간 복잡도**(Time complexity)가 어느정도 된다. 이를 표현하는 방법으로 Big O Notation

알고리즘의 작업량을 표현할 때 시간 복잡도로 표현. 실행되는 명령문의 개수를 계산 한다.

### Pro 문제는 n^2를 nlogn으로 바꾸거나, n을 logn으로 바꾸는것

### 우리는 일단 퍼포먼스는 나중에 고려하고, 답이 나오는데에 초점을 맞춰보자.

Array (알고리즘 차원에서) : 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

C에서는 array에 정적 할당을 해주나, python은 동적 바인딩을 한다.

## IM에서 중요시 생각하는 것 중 하나가 Boundary check. 이 Boundary를 정확하게 통제 할 수 있어야 한다.

## 추가적으로 문제를 구현 할 때 예외 케이스에 대해 생각 해 볼것.

### 문제 풀 때 1 : 논리를 생각 / 2: 코딩을 함 / 이 경계가 모호하고, 같이 번갈아 가면서 작업 하는건 정말 안좋은 습관.

### 즉, 먼저 분석과 설계가 충분 할 수록 프로그래밍 시간이 줄어든다.

### Baby-Gin Problem

순열(중복) / 조합(중복) / 부분집합

* 완전검색(Exhaustive Search) : Brute-force 혹은 Generate and test 기법
* 모든 경우의 수를 테스트 한 후 최종 해법 도출
* 경우의 수가 상대적으로 작을 때 유용

Advanced : 완전 검색으로 접근하여 정확한 해답을 도출

Pro : 성능 개선을 위해 알고리즘 사용(그리드, DP), 해답 확인

***

## 탐욕 알고리즘(완전 검색과는 다름)

### 1. 알고리즘 설계 기법으로 최적해를 구하는 데 사용되는 근시안적인 방법.

** 결정문제 ** True or False 문제.

=> 문제를 풀 때 최적해 문제의 경우 범위를 결정해로 수정 후, 다시 최적화를 다룬다.

### 2. 순간에 최적이라고 생각되는 것을 선택해 나가면서 최종적인 해답에 도달

### 3. 각 시점에서는 최적이나 최종적으로는 최적이라는 보장이 없음.

### 4. 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근법

### 5. 굉장히 위험한 접근법으로, 신중히 들어가야 한다.

### 6. 풀어야 할 문제의 범위를 최대한 줄이는 것.

=> 완전 검색으로는 이렇게 되는데 그리디는 이런거구나 이렇게 비교 분석하면서 문제 풀이.

문제법과, 이에 대한 검증이 필요하다. 즉 코딩을 하는게 아니라, 어떻게 해결할지에 대한 생각.

그리드는, 효율적일 수도 있다. 그러나, 때로는 그리디의 문제가 발생할 수도 있다.

그렇기에 완전 탐색의 경우로 문제를 스캔 한 후, 예외 케이스를 고려해서 접근해야 한다.

***

### 정렬이 무조건 옳은 것은 아니다

[6,4,4,5,4,4] => babygin

[1,2,3,1,2,3] [1,1,2,2,3,3] =>babygin but  정렬시 문제가 생긴다. 판단의 문제가 생겨버림

그래서 이 문제의 경우 count array를 사용하는 편이 더 낫다.

***

### Sort

* Bubble
* Counting
* Selection
* Quick
* Insertion
* Merge

알고리즘 느는 방법은 코드를 그대로 시뮬레이션 해보는 것

#### 버블정렬은 제일큰게 맨 뒤로 가게됨 => sorted!

#### 이런 똑같은 것을 또 반복 또 반복











